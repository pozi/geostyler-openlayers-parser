{"version":3,"file":"OlStyleUtil.js","sourceRoot":"","sources":["../../src/Util/OlStyleUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n  Expression,\r\n  MarkSymbolizer,\r\n  PropertyType,\r\n  Style,\r\n  TextSymbolizer\r\n} from 'geostyler-style/dist/style';\r\n\r\nimport {\r\n  Fcase,\r\n  GeoStylerBooleanFunction,\r\n  GeoStylerFunction,\r\n  GeoStylerNumberFunction,\r\n  GeoStylerStringFunction,\r\n  GeoStylerUnknownFunction,\r\n} from 'geostyler-style/dist/functions';\r\n\r\nimport {\r\n  isGeoStylerBooleanFunction,\r\n  isGeoStylerFunction,\r\n  isGeoStylerNumberFunction,\r\n  isGeoStylerStringFunction,\r\n  isGeoStylerUnknownFunction\r\n} from 'geostyler-style/dist/typeguards';\r\n\r\nimport OlFeature from 'ol/Feature';\r\nimport { colors } from './colors';\r\n\r\nconst WELLKNOWNNAME_TTF_REGEXP = /^ttf:\\/\\/(.+)#(.+)$/;\r\nexport const DUMMY_MARK_SYMBOLIZER_FONT = 'geostyler-mark-symbolizer';\r\n\r\n/**\r\n * Offers some utility functions to work with OpenLayers Styles.\r\n */\r\nclass OlStyleUtil {\r\n\r\n  /**\r\n   * Transforms a HEX encoded color and an opacity value to a RGB(A) notation.\r\n   *\r\n   * @param colorString HEX encoded color\r\n   * @param opacity  Opacity (Betweeen 0 and 1)\r\n   * @return the RGB(A) value of the input color\r\n   */\r\n  public static getRgbaColor(colorString: string | GeoStylerStringFunction, opacity: number | GeoStylerNumberFunction) {\r\n    if (isGeoStylerStringFunction(colorString)) {\r\n      colorString = OlStyleUtil.evaluateStringFunction(colorString);\r\n    }\r\n\r\n    if (typeof(colorString) !== 'string') {\r\n      return;\r\n    }\r\n    if (colorString.startsWith('rgba(')) {\r\n      return colorString;\r\n    }\r\n\r\n    // check if is valid HEX color - see also here\r\n    // https://stackoverflow.com/questions/8027423/how-to-check-if-a-string-is-a-valid-hex-color-representation/8027444\r\n    const isHexColor = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(colorString);\r\n    if (!isHexColor) {\r\n      return;\r\n    }\r\n\r\n    const r = parseInt(colorString.slice(1, 3), 16);\r\n    const g = parseInt(colorString.slice(3, 5), 16);\r\n    const b = parseInt(colorString.slice(5, 7), 16);\r\n\r\n    if (isGeoStylerNumberFunction(opacity)) {\r\n      opacity = OlStyleUtil.evaluateNumberFunction(opacity);\r\n    }\r\n\r\n    if (opacity < 0) {\r\n      opacity = 1;\r\n    }\r\n\r\n    return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + opacity + ')';\r\n  }\r\n\r\n  /**\r\n   * Splits a RGBA encoded color into its color values.\r\n   *\r\n   * @param {string} rgbaColor RGB(A) encoded color\r\n   * @return {number[]} Numeric color values as array\r\n   */\r\n  public static splitRgbaColor(rgbaColor: string): number[] {\r\n    const colorsOnly = rgbaColor.substring(rgbaColor.indexOf('(') + 1, rgbaColor.lastIndexOf(')')).split(/,\\s*/);\r\n    const red = parseInt(colorsOnly[0], 10);\r\n    const green = parseInt(colorsOnly[1], 10);\r\n    const blue = parseInt(colorsOnly[2], 10);\r\n    const opacity = parseFloat(colorsOnly[3]);\r\n\r\n    return [red, green, blue, opacity];\r\n  }\r\n\r\n  /**\r\n   * Transforms a RGB(A) or named color value to a HEX encoded notation.\r\n   * If a HEX color is provided it will be returned untransformed.\r\n   *\r\n   * @param {string} inColor The color to transform\r\n   * @return {string | undefined} The HEX color representation of the given color\r\n   */\r\n  public static getHexColor(inColor: string): string | undefined {\r\n    // if passing in a hex code we just return it\r\n    if (inColor.startsWith('#')) {\r\n      return inColor;\r\n    } else if (inColor.startsWith('rgb')) {\r\n      const colorArr = OlStyleUtil.splitRgbaColor(inColor);\r\n      return OlStyleUtil.getHexCodeFromRgbArray(colorArr);\r\n    } else if (colors[inColor.toLocaleLowerCase()] !== undefined) {\r\n      const rgbColorArr = colors[inColor.toLocaleLowerCase()];\r\n      return OlStyleUtil.getHexCodeFromRgbArray(rgbColorArr);\r\n    } else {\r\n      return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the hex code for a given RGB(A) array.\r\n   *\r\n   * @param colorArr RGB(A) array. e.g. [255,0,0]\r\n   * @return {string} The HEX color representation of the given color\r\n   */\r\n  public static getHexCodeFromRgbArray(colorArr: number[]): string {\r\n    return '#' + colorArr.map((x, idx) => {\r\n      const hex = x.toString(16);\r\n      // skip opacity if passed as fourth entry\r\n      if (idx < 3) {\r\n        return hex.length === 1 ? '0' + hex : hex;\r\n      }\r\n      return '';\r\n    }).join('');\r\n  }\r\n\r\n  /**\r\n   * Returns the opacity value of a RGB(A) color value.\r\n   *\r\n   * @param rgbaColor RGBA encoded color\r\n   * @return {string | undefined} The opacity value of the given RGBA color\r\n   */\r\n  public static getOpacity(rgbaColor: string): number | undefined {\r\n    if (!rgbaColor.startsWith('rgba(')) {\r\n      return;\r\n    }\r\n\r\n    const colorArr = OlStyleUtil.splitRgbaColor(rgbaColor);\r\n\r\n    if (colorArr.length === 4) {\r\n      return colorArr[3];\r\n    } else {\r\n      return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an OL compliant font string.\r\n   *\r\n   * @param symbolizer The TextSymbolizer to derive the font string from\r\n   */\r\n  public static getTextFont(symbolizer: TextSymbolizer) {\r\n    const fontWeight = symbolizer.fontWeight ?? 'normal';\r\n    const fontStyle = symbolizer.fontStyle ?? 'normal';\r\n\r\n    const size = symbolizer.size;\r\n    const font = symbolizer.font;\r\n    return fontWeight + ' ' + fontStyle + ' ' + size + 'px ' + font?.join(', ');\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns true if the given mark symbolizer is based on a font glyph\r\n   * (i.e. has a well known name property starting with 'ttf://').\r\n   *\r\n   * @param symbolizer The TextSymbolizer to derive the font string from\r\n   */\r\n  public static getIsFontGlyphBased(symbolizer: MarkSymbolizer) {\r\n    return WELLKNOWNNAME_TTF_REGEXP.test(symbolizer.wellKnownName);\r\n  }\r\n\r\n  /**\r\n   * Returns whether the given font (as used in the OpenLayers Text Style `font` property)\r\n   * is intended for a mark symbolizer or not.\r\n   * This is done by checking whether the dummy DUMMY_MARK_SYMBOLIZER_FONT font name is present.\r\n   *\r\n   * @param font The text font to analyze\r\n   */\r\n  public static getIsMarkSymbolizerFont(font: string) {\r\n    if (!font) {\r\n      return false;\r\n    }\r\n    const search = DUMMY_MARK_SYMBOLIZER_FONT;\r\n    return font.substring(font.length - search.length, font.length) === search;\r\n  }\r\n\r\n  /**\r\n   * Returns an OL compliant font string, to be used for mark symbolizers\r\n   * using a font glyph.\r\n   * This also includes a dummy DUMMY_MARK_SYMBOLIZER_FONT font name at the end of the\r\n   * string to allow determining that this font was intended for a mark symbolizer\r\n   * later on.\r\n   *\r\n   * @param symbolizer The TextSymbolizer to derive the font string from\r\n   */\r\n  public static getTextFontForMarkSymbolizer(symbolizer: MarkSymbolizer) {\r\n    const parts = symbolizer.wellKnownName.match(WELLKNOWNNAME_TTF_REGEXP);\r\n    if (!parts) {\r\n      throw new Error(`Could not parse font-based well known name: ${symbolizer.wellKnownName}`);\r\n    }\r\n    const fontFamily = parts[1];\r\n    return `Normal ${symbolizer.radius || 5}px '${fontFamily}', ${DUMMY_MARK_SYMBOLIZER_FONT}`;\r\n  }\r\n\r\n  /**\r\n   * Returns a 1-char string to be used as text for mark symbolizers using a font glyph.\r\n   *\r\n   * @param symbolizer The MarkSymbolizer to derive the character string from\r\n   */\r\n  public static getCharacterForMarkSymbolizer(symbolizer: MarkSymbolizer) {\r\n    const parts = symbolizer.wellKnownName.match(WELLKNOWNNAME_TTF_REGEXP);\r\n    if (!parts) {\r\n      throw new Error(`Could not parse font-based well known name: ${symbolizer.wellKnownName}`);\r\n    }\r\n    return String.fromCharCode(parseInt(parts[2], 16));\r\n  }\r\n\r\n  /**\r\n   * Returns the font name used in the OpenLayers text style `font` property.\r\n   *\r\n   * @param olFont the `font` property of an OpenLayers text style\r\n   */\r\n  public static getFontNameFromOlFont(olFont: string) {\r\n    const parts = olFont.match(/(?:\\d+\\S+) '?\"?([^,'\"]+)/);\r\n    if (!parts) {\r\n      throw new Error(`Could not find font family name in the following string: ${olFont}`);\r\n    }\r\n    return parts[1];\r\n  }\r\n\r\n  /**\r\n   * Returns the size in pixels specified in the OpenLayers text style `font` property,\r\n   * or 0 if not found.\r\n   *\r\n   * @param olFont the `font` property of an OpenLayers text style\r\n   */\r\n  public static getSizeFromOlFont(olFont: string) {\r\n    const parts = olFont.match(/(?:(\\d+)px)/);\r\n    return parts ? parseInt(parts[1], 10) : 0;\r\n  }\r\n\r\n  /**\r\n   * Resolves the given template string with the given feature attributes, e.g.\r\n   * the template \"Size of area is {{AREA_SIZE}} km²\" would be to resolved\r\n   * to \"Size of area is 1909 km²\" (assuming the feature's attribute AREA_SIZE\r\n   * really exists).\r\n   *\r\n   * @param feature The feature to get the attributes from.\r\n   * @param template The template string to resolve.\r\n   * @param [noValueFoundText] The text to apply, if the templated value\r\n   *   could not be found, default is to 'n.v.'.\r\n   * @param [valueAdjust] A method that will be called with each\r\n   *   key/value match, we'll use what this function returns for the actual\r\n   *   replacement. Optional, defaults to a function which will return the raw\r\n   *   value it received. This can be used for last minute adjustments before\r\n   *   replacing happens, e.g. to filter out falsy values or to do number\r\n   *   formatting and such.\r\n   * @return The resolved template string.\r\n   */\r\n  static resolveAttributeTemplate(\r\n    feature: OlFeature,\r\n    template: string,\r\n    noValueFoundText: string = 'n.v.',\r\n    valueAdjust: Function = (key: string, val: any) => val\r\n  ) {\r\n\r\n    let attributeTemplatePrefix = '\\\\{\\\\{';\r\n    let attributeTemplateSuffix = '\\\\}\\\\}';\r\n\r\n    // Find any character between two braces (including the braces in the result)\r\n    let regExp = new RegExp(attributeTemplatePrefix + '(.*?)' + attributeTemplateSuffix, 'g');\r\n    let regExpRes = template.match(regExp);\r\n\r\n    // If we have a regex result, it means we found a placeholder in the\r\n    // template and have to replace the placeholder with its appropriate value.\r\n    if (regExpRes) {\r\n      // Iterate over all regex match results and find the proper attribute\r\n      // for the given placeholder, finally set the desired value to the hover.\r\n      // field text\r\n      regExpRes.forEach(res => {\r\n        // We count every non matching candidate. If this count is equal to\r\n        // the objects length, we assume that there is no match at all and\r\n        // set the output value to the value of \"noValueFoundText\".\r\n        let noMatchCnt = 0;\r\n\r\n        for (let [key, value] of Object.entries(feature.getProperties())) {\r\n          // Remove the suffixes and find the matching attribute column.\r\n          let attributeName = res.slice(2, res.length - 2);\r\n\r\n          if (attributeName.toLowerCase() === key.toLowerCase()) {\r\n            template = template.replace(res, valueAdjust(key, value));\r\n            break;\r\n          } else {\r\n            noMatchCnt++;\r\n          }\r\n        }\r\n\r\n        // No key match found for this feature (e.g. if key not\r\n        // present or value is null).\r\n        if (noMatchCnt === Object.keys(feature.getProperties()).length) {\r\n          template = template.replace(res, noValueFoundText);\r\n        }\r\n      });\r\n    }\r\n\r\n    return template;\r\n  }\r\n\r\n  public static evaluateFunction(func: GeoStylerFunction, feature?: OlFeature): PropertyType {\r\n    if (func.name === 'property') {\r\n      if (!feature) {\r\n        throw new Error(`Could not evalute 'property' function. Feature ${feature} is not defined.`);\r\n      }\r\n      if (isGeoStylerStringFunction(func.args[0])) {\r\n        return feature?.get(OlStyleUtil.evaluateStringFunction(func.args[0], feature));\r\n      } else {\r\n        return feature?.get(func.args[0]);\r\n      }\r\n    }\r\n\r\n    if (isGeoStylerUnknownFunction(func)) {\r\n      return OlStyleUtil.evaluateUnknownFunction(func, feature);\r\n    }\r\n    if (isGeoStylerStringFunction(func)) {\r\n      return OlStyleUtil.evaluateStringFunction(func, feature);\r\n    }\r\n    if (isGeoStylerNumberFunction(func)) {\r\n      return OlStyleUtil.evaluateNumberFunction(func, feature);\r\n    }\r\n    if (isGeoStylerBooleanFunction(func)) {\r\n      return OlStyleUtil.evaluateBooleanFunction(func, feature);\r\n    }\r\n    return;\r\n  }\r\n\r\n  public static evaluateBooleanFunction(func: GeoStylerBooleanFunction, feature?: OlFeature): boolean {\r\n    const args = func.args.map(arg => {\r\n      if (isGeoStylerFunction(arg)) {\r\n        return OlStyleUtil.evaluateFunction(arg, feature);\r\n      }\r\n      return arg;\r\n    });\r\n    switch (func.name) {\r\n      case 'all':\r\n        return args.map(arg => this.evaluateBooleanFunction(arg as GeoStylerBooleanFunction, feature))\r\n          .every(result => result === true);\r\n      case 'any':\r\n        return args.map(arg => this.evaluateBooleanFunction(arg as GeoStylerBooleanFunction, feature))\r\n          .some(result => result === true);\r\n      case 'between':\r\n        return (args[0] as number) >= (args[1] as number) && (args[0] as number) <= (args[2] as number);\r\n      case 'double2bool':\r\n        // TODO: evaluate this correctly\r\n        return false;\r\n      case 'equalTo':\r\n        return args[0] === args[1];\r\n      case 'greaterThan':\r\n        return (args[0] as number) > (args[1] as number);\r\n      case 'greaterThanOrEqualTo':\r\n        return (args[0] as number) >= (args[1] as number);\r\n      case 'in':\r\n        return args.slice(1).includes(args[0]);\r\n      case 'lessThan':\r\n        return (args[0] as number) < (args[1] as number);\r\n      case 'lessThanOrEqualTo':\r\n        return (args[0] as number) <= (args[1] as number);\r\n      case 'not':\r\n        return !args[0];\r\n      case 'notEqualTo':\r\n        return args[0] !== args[1];\r\n      case 'parseBoolean':\r\n        return !!args[0];\r\n      case 'strEndsWith':\r\n        return (args[0] as string).endsWith(args[1] as string);\r\n      case 'strEqualsIgnoreCase':\r\n        return (args[0] as string).toLowerCase() === (args[1] as string).toLowerCase() ;\r\n      case 'strMatches':\r\n        const regEx = (args[1] as string);\r\n        const regexArray = regEx.match(/\\/(.*?)\\/([gimy]{0,4})$/);\r\n        if (regexArray && regexArray.length === 3){\r\n          return new RegExp(regexArray[1], regexArray[2]).test(args[0] as string);\r\n        } else {\r\n          return false;\r\n        }\r\n      case 'strStartsWith':\r\n        return (args[0] as string).startsWith(args[1] as string);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  public static evaluateNumberFunction(func: GeoStylerNumberFunction, feature?: OlFeature): number {\r\n    if (func.name === 'pi') {\r\n      return Math.PI;\r\n    }\r\n    if (func.name === 'random') {\r\n      return Math.random();\r\n    }\r\n    const args = func.args.map(arg => {\r\n      if (isGeoStylerFunction(arg)) {\r\n        return OlStyleUtil.evaluateFunction(arg, feature);\r\n      }\r\n      return arg;\r\n    });\r\n    switch (func.name) {\r\n      case 'abs':\r\n        return Math.abs(args[0] as number);\r\n      case 'acos':\r\n        return Math.acos(args[0] as number);\r\n      case 'add':\r\n        return (args[0] as number) + (args[1] as number);\r\n      case 'asin':\r\n        return Math.asin(args[0] as number);\r\n      case 'atan':\r\n        return Math.atan(args[0] as number);\r\n      case 'atan2':\r\n        // TODO: evaluate this correctly\r\n        return args[0] as number;\r\n      case 'ceil':\r\n        return Math.ceil(args[0] as number);\r\n      case 'cos':\r\n        return Math.cos(args[0] as number);\r\n      case 'div':\r\n        return (args[0] as number) / (args[1] as number);\r\n      case 'exp':\r\n        return Math.exp(args[0] as number);\r\n      case 'floor':\r\n        return Math.floor(args[0] as number);\r\n      case 'log':\r\n        return Math.log(args[0] as number);\r\n      case 'max':\r\n        return Math.max(...(args as number[]));\r\n      case 'min':\r\n        return Math.min(...(args as number[]));\r\n      case 'modulo':\r\n        return (args[0] as number) % (args[1] as number);\r\n      case 'mul':\r\n        return (args[0] as number) * (args[1] as number);\r\n      case 'pow':\r\n        return Math.pow(args[0] as number, args[1] as number);\r\n      case 'rint':\r\n        // TODO: evaluate this correctly\r\n        return args[0] as number;\r\n      case 'round':\r\n        return Math.round(args[0] as number);\r\n      case 'sin':\r\n        return Math.sin(args[0] as number);\r\n      case 'sqrt':\r\n        return Math.sqrt(args[0] as number);\r\n      case 'strIndexOf':\r\n        return (args[0] as string).indexOf(args[1] as string);\r\n      case 'strLastIndexOf':\r\n        return (args[0] as string).lastIndexOf(args[1] as string);\r\n      case 'strLength':\r\n        return (args[0] as string).length;\r\n      case 'sub':\r\n        return (args[0] as number) - (args[1] as number);\r\n      case 'tan':\r\n        return Math.tan(args[0] as number);\r\n      case 'toDegrees':\r\n        return (args[0] as number) * (180/Math.PI);\r\n      case 'toRadians':\r\n        return (args[0] as number) * (Math.PI/180);\r\n      default:\r\n        return args[0] as number;\r\n    }\r\n  }\r\n\r\n  public static evaluateUnknownFunction(func: GeoStylerUnknownFunction, feature?: OlFeature): unknown {\r\n    const args = func.args.map(arg => {\r\n      if (isGeoStylerFunction(arg)) {\r\n        return OlStyleUtil.evaluateFunction(arg, feature);\r\n      }\r\n      return arg;\r\n    });\r\n    switch (func.name) {\r\n      case 'property':\r\n        return feature?.get(args[0] as string);\r\n      case 'case':\r\n        type FCaseParameter = {\r\n          case: Expression<boolean>;\r\n          value: Expression<PropertyType>;\r\n        };\r\n        const caseArgs: Fcase['args'] = args as Fcase['args'];\r\n        let match;\r\n        for (let index = 0; index < caseArgs.length; index++) {\r\n          const caseArg = caseArgs[index] as FCaseParameter;\r\n          // last arg of the case-function-expression is the default value\r\n          if (index === caseArgs.length - 1) {\r\n            match = caseArg;\r\n            break;\r\n          // the case can be a boolean\r\n          } else if (caseArg.case === true) {\r\n            match = caseArg.value;\r\n            break;\r\n          // … or a boolean function that has to be evaluated first\r\n          } else if (OlStyleUtil.evaluateBooleanFunction(caseArg.case as GeoStylerBooleanFunction, feature)) {\r\n            match = caseArg.value;\r\n            break;\r\n          }\r\n        }\r\n        return match;\r\n      default:\r\n        return args[0];\r\n    }\r\n  }\r\n\r\n  public static evaluateStringFunction(func: GeoStylerStringFunction, feature?: OlFeature): string {\r\n    const args = func.args.map(arg => {\r\n      if (isGeoStylerFunction(arg)) {\r\n        return OlStyleUtil.evaluateFunction(arg, feature);\r\n      }\r\n      return arg;\r\n    });\r\n    switch (func.name) {\r\n      case 'numberFormat':\r\n        // TODO: evaluate this correctly\r\n        return args[0] as string;\r\n      case 'strAbbreviate':\r\n        // TODO: evaluate this correctly\r\n        return args[0] as string;\r\n      case 'strCapitalize':\r\n        // https://stackoverflow.com/a/32589289/10342669\r\n        var splitStr = (args[0] as string).toLowerCase().split(' ');\r\n        for (let part of splitStr) {\r\n          part = part.charAt(0).toUpperCase() + part.substring(1);\r\n        }\r\n        return splitStr.join(' ');\r\n      case 'strConcat':\r\n        return args.join();\r\n      case 'strDefaultIfBlank':\r\n        return (args[0] as string)?.length < 1 ? args[1] as string : args[0] as string;\r\n      case 'strReplace':\r\n        if (args[3] === true) {\r\n          return (args[0] as string).replaceAll(args[1] as string, args[2] as string);\r\n        } else {\r\n          return (args[0] as string).replace(args[1] as string, args[2] as string);\r\n        }\r\n      case 'strStripAccents':\r\n        // https://stackoverflow.com/a/37511463/10342669\r\n        return (args[0] as string).normalize('NFKD').replace(/[\\u0300-\\u036f]/g, '');\r\n      case 'strSubstring':\r\n        return (args[0] as string).substring(args[1] as number, args[2] as number);\r\n      case 'strSubstringStart':\r\n        return (args[0] as string).substring(args[1] as number);\r\n      case 'strToLowerCase':\r\n        return (args[0] as string).toLowerCase();\r\n      case 'strToUpperCase':\r\n        return (args[0] as string).toUpperCase();\r\n      case 'strTrim':\r\n        return (args[0] as string).trim();\r\n      default:\r\n        return args[0] as string;\r\n    }\r\n  }\r\n\r\n  public static containsGeoStylerFunctions(style: Style) {\r\n    return style.rules.some(rule => {\r\n      const filterHasFunction = Array.isArray(rule.filter) && rule.filter?.some(isGeoStylerFunction);\r\n      const styleHasFunction = rule.symbolizers?.some(symbolizer => {\r\n        return Object.values(symbolizer).some(isGeoStylerFunction);\r\n      });\r\n      const scaleDenominatorHasFunction = isGeoStylerFunction(rule?.scaleDenominator?.max)\r\n      || isGeoStylerFunction(rule?.scaleDenominator?.min);\r\n      return filterHasFunction || styleHasFunction || scaleDenominatorHasFunction;\r\n    });\r\n  }\r\n}\r\n\r\nexport default OlStyleUtil;\r\n"]}